# -*- coding: utf-8 -*-
"""setimaed.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-hz1gfCZSZOmsTK_HvZDPAz3pRoTYbHh

# **QUEST√ÉO 7**

# Item A
"""

import random
import time

class Node:
    def __init__(self, value):
        self.value = value
        self.next = None
        self.prev = None

class Deque:
    def __init__(self):
        self.front = None
        self.rear = None
        self.size = 0

    def is_empty(self):
        return self.size == 0

    def is_full(self):
        return False  # Em uma implementa√ß√£o din√¢mica, n√£o h√° limite de tamanho

    def add_front(self, value):
        new_node = Node(value)
        if self.is_empty():
            self.front = new_node
            self.rear = new_node
            new_node.next = new_node
            new_node.prev = new_node
        else:
            new_node.next = self.front
            new_node.prev = self.rear
            self.front.prev = new_node
            self.rear.next = new_node
            self.front = new_node
        self.size += 1

    def add_rear(self, value):
        new_node = Node(value)
        if self.is_empty():
            self.front = new_node
            self.rear = new_node
            new_node.next = new_node
            new_node.prev = new_node
        else:
            new_node.next = self.front
            new_node.prev = self.rear
            self.rear.next = new_node
            self.front.prev = new_node
            self.rear = new_node
        self.size += 1

    def remove_front(self):
        if self.is_empty():
            raise IndexError("Deque is empty")
        if self.front == self.rear:
            self.front = None
            self.rear = None
        else:
            self.front = self.front.next
            self.rear.next = self.front
            self.front.prev = self.rear
        self.size -= 1

    def remove_rear(self):
        if self.is_empty():
            raise IndexError("Deque is empty")
        if self.front == self.rear:
            self.front = None
            self.rear = None
        else:
            self.rear = self.rear.prev
            self.front.prev = self.rear
            self.rear.next = self.front
        self.size -= 1

    def peek_front(self):
        if self.is_empty():
            raise IndexError("Deque is empty")
        return self.front.value

    def peek_rear(self):
        if self.is_empty():
            raise IndexError("Deque is empty")
        return self.rear.value

    def display(self):
        if self.is_empty():
            print("Deque is empty")
            return
        current = self.front
        while current != self.rear:
            print(current.value, end=" <-> ")
            current = current.next
        print(current.value)

# Fun√ß√£o para medir o tempo de execu√ß√£o
import time
def measure_time(func, *args):
    start_time = time.time()
    func(*args)
    end_time = time.time()
    return end_time - start_time

# Testando a implementa√ß√£o
for size in [100, 1000, 10000, 1000000]:
    deque = Deque()
    # Medindo o tempo de inicializa√ß√£o
    init_time = measure_time(deque.__init__)
    print(f"Tamanho do deque: {size}")
    print(f"Tempo de inicializa√ß√£o: {init_time:.6f} segundos")

    # Adicionando elementos ao deque
    for i in range(size):
        deque.add_rear(i)

    # Exibindo alguns elementos
    deque.display()

    # Removendo elementos
    for i in range(size // 10):  # Remover 10% dos elementos
        deque.remove_front()
        deque.remove_rear()

    # Exibindo o deque ap√≥s remo√ß√µes
    deque.display()

"""A estrutura suporta inser√ß√µes e remo√ß√µes eficientes tanto na extremidade frontal quanto na traseira. O deque √© din√¢mico e n√£o possui limite de tamanho. Al√©m disso, h√° uma fun√ß√£o para medir o tempo de execu√ß√£o de opera√ß√µes realizadas sobre o deque.

No final, o c√≥digo realiza testes em deques de tamanhos variados (100, 1.000, 10.000 e 1.000.000), medindo tempos de execu√ß√£o para inicializa√ß√£o, inser√ß√µes e remo√ß√µes.

Resultados de Execu√ß√£o
Tamanho do deque pequeno (100 elementos):

Inicializa√ß√£o: extremamente r√°pida (tempo pr√≥ximo de 0).
Inser√ß√µes e remo√ß√µes acontecem de forma eficiente, com tempos de execu√ß√£o baixos.
A exibi√ß√£o funciona adequadamente.
Tamanho do deque grande (1.000.000 elementos):

Inser√ß√µes podem levar alguns segundos devido ao grande n√∫mero de opera√ß√µes.
Remo√ß√µes tamb√©m apresentam tempos proporcionais √† quantidade de elementos processados.
A exibi√ß√£o completa do deque pode ser impratic√°vel para tamanhos grandes devido ao volume de sa√≠da no console.

As opera√ß√µes b√°sicas do deque (add, remove, peek) s√£o altamente eficientes (O(1)). Apenas opera√ß√µes como exibi√ß√£o ou processamento em massa t√™m complexidade linear (O(n)), onde
ùëõ
n √© o n√∫mero de elementos.

# Item B
"""

class Node:
    def __init__(self, value):
        self.value = value
        self.next = None

class DequeCircular:
    def __init__(self):
        self.front = None
        self.rear = None
        self.size = 0

    def Deque_√©_vazio(self):
        return self.size == 0

    def adicionar_frente(self, value):
        new_node = Node(value)
        if self.Deque_√©_vazio():
            self.front = new_node
            self.rear = new_node
            new_node.next = new_node
        else:
            new_node.next = self.front
            self.front = new_node
            self.rear.next = self.front
        self.size += 1

    def adicionar_tr√°s(self, value):
        new_node = Node(value)
        if self.Deque_√©_vazio():
            self.front = new_node
            self.rear = new_node
            new_node.next = new_node
        else:
            new_node.next = self.front
            self.rear.next = new_node
            self.rear = new_node
        self.size += 1

    def remover_frente(self):
        if self.Deque_√©_vazio():
            raise IndexError("O deque est√° vazio.")

        value = self.front.value
        if self.front == self.rear:
            self.front = None
            self.rear = None
        else:
            self.front = self.front.next
            self.rear.next = self.front
        self.size -= 1
        return value

    def remover_tr√°s(self):
        if self.Deque_√©_vazio():
            raise IndexError("O deque est√° vazio.")

        value = self.rear.value
        if self.front == self.rear:
            self.front = None
            self.rear = None
        else:
            current = self.front
            while current.next != self.rear:
                current = current.next
            current.next = self.front
            self.rear = current
        self.size -= 1
        return value

def medir_tempo(func, *args):
    inicio = time.time()
    func(*args)
    fim = time.time()
    return fim - inicio

tamanhos = [1000, 10000, 1000000]

for tamanho in tamanhos:
    deque = DequeCircular()
    tempo_inicializacao = medir_tempo(deque.__init__)
    print(f"Tamanho do deque: {tamanho}")
    print(f"Tempo de inicializa√ß√£o: {tempo_inicializacao:.6f} segundos")

    tempo_adicionar = medir_tempo(
        lambda: [deque.adicionar_tr√°s(i) for i in range(tamanho)]
    )
    print(f"Tempo para adicionar {tamanho} elementos: {tempo_adicionar:.6f} segundos")

    tempo_remover = medir_tempo(
        lambda: [deque.remover_frente() for _ in range(tamanho // 10)]
    )
    print(f"Tempo para remover 10% dos elementos: {tempo_remover:.6f} segundos\n")

"""A complexidade total de cada opera√ß√£o varia de O(1) para inser√ß√£o e remo√ß√£o na frente at√© O(n) para remo√ß√£o do final.

O tempo de execu√ß√£o varia conforme o tamanho do deque, especialmente nas opera√ß√µes de inser√ß√£o e remo√ß√£o. A medi√ß√£o do tempo √© feita para os seguintes tamanhos de deque: 1000, 10000 e 1000000.

O tempo de execu√ß√£o das opera√ß√µes de inser√ß√£o e remo√ß√£o depende do tamanho do deque:

Inser√ß√µes (adicionar_frente, adicionar_tr√°s) t√™m tempo de execu√ß√£o O(1), o que significa que o tempo de execu√ß√£o permanece constante independentemente do n√∫mero de elementos.
Remo√ß√µes da Frente (remover_frente) tamb√©m t√™m tempo de execu√ß√£o O(1).
Remo√ß√µes do Final (remover_tr√°s) t√™m tempo de execu√ß√£o O(n), pois √© necess√°rio percorrer a lista para encontrar o pen√∫ltimo n√≥.

# Item C
"""

class Node:
    def __init__(self, value):
        self.value = value
        self.next = None

class FilaCircular:
    def __init__(self):
        self.front = None
        self.rear = None
        self.size = 0

    def fila_√©_vazia(self):
        return self.size == 0

    def fila_√©_cheia(self):
        # Em uma implementa√ß√£o din√¢mica, a fila nunca estar√° cheia
        return False

    def enfileirar(self, value):
        new_node = Node(value)
        if self.fila_√©_vazia():
            self.front = new_node
            self.rear = new_node
            new_node.next = self.front  # Lista circular
        else:
            self.rear.next = new_node
            self.rear = new_node
            self.rear.next = self.front  # Mant√©m a circularidade
        self.size += 1

    def desenfileirar(self):
        if self.fila_√©_vazia():
            raise IndexError("Fila est√° vazia")
        if self.front == self.rear:
            self.front = None
            self.rear = None
        else:
            self.front = self.front.next
            self.rear.next = self.front
        self.size -= 1

    def frente(self):
        if self.fila_√©_vazia():
            raise IndexError("Fila est√° vazia")
        return self.front.value

    def tamanho(self):
        return self.size

    def exibir(self):
        if self.fila_√©_vazia():
            print("Fila est√° vazia.")
            return
        print(f"Fila cont√©m {self.size} elementos.")

# Fun√ß√£o para medir o tempo de execu√ß√£o
import time
def medir_tempo(func, *args):
    start_time = time.time()
    func(*args)
    end_time = time.time()
    return end_time - start_time

# Testando a implementa√ß√£o
for size in [1000, 10000, 1000000]:
    fila = FilaCircular()
    # Medindo o tempo de inicializa√ß√£o
    tempo_init = medir_tempo(fila.__init__)
    print(f"Tamanho da fila: {size}")
    print(f"Tempo de inicializa√ß√£o: {tempo_init:.6f} segundos")

    # Enfileirando elementos
    for i in range(size):
        fila.enfileirar(i)

    # Exibindo a fila (apenas mostrando o tamanho)
    fila.exibir()

    # Desenfileirando elementos
    for i in range(size // 10):  # Remover 10% dos elementos
        fila.desenfileirar()

    # Exibindo a fila ap√≥s as remo√ß√µes (apenas mostrando o tamanho)
    fila.exibir()

"""Os tempos de inicializa√ß√£o e opera√ß√µes de enfileiramento/desenfileiramento ser√£o mais evidentes √† medida que o n√∫mero de elementos cresce, mas com a implementa√ß√£o atual, as opera√ß√µes s√£o de complexidade O(1), logo, o tempo de execu√ß√£o por opera√ß√£o n√£o aumenta drasticamente com o n√∫mero de elementos

Tempo de Execu√ß√£o: O c√≥digo √© r√°pido para tamanhos grandes, pois cada opera√ß√£o √© constante

# Item D
"""

import time

class Node:
    def __init__(self, value):
        self.value = value  # Valor armazenado no n√≥
        self.next = None  # Ponteiro para o pr√≥ximo n√≥

class FilaCircular:
    def __init__(self):
        self.front = None  # In√≠cio da fila
        self.rear = None   # Fim da fila
        self.size = 0      # Tamanho da fila

    def fila_√©_vazia(self):
        return self.size == 0  # A fila est√° vazia se o tamanho for zero

    def fila_√©_cheia(self):
        return False  # Em uma implementa√ß√£o din√¢mica, a fila nunca est√° cheia

    def insere_fila(self, value):
        """
        Insere um valor no final da fila (enfileiramento).
        """
        new_node = Node(value)  # Cria√ß√£o de um novo n√≥ com o valor

        if self.fila_√©_vazia():  # Se a fila estiver vazia, o novo n√≥ ser√° o √∫nico na fila
            self.front = new_node
            self.rear = new_node
            new_node.next = new_node  # O n√≥ aponta para ele mesmo (circular)
        else:  # Se a fila n√£o estiver vazia
            self.rear.next = new_node  # O n√≥ atual aponta para o novo n√≥
            self.rear = new_node       # O rear agora ser√° o novo n√≥
            self.rear.next = self.front  # O √∫ltimo n√≥ aponta de volta para o in√≠cio (circular)

        self.size += 1  # Incrementa o tamanho da fila

    def desenfileira(self):
        """
        Remove um elemento do in√≠cio da fila (desenfileiramento).
        """
        if self.fila_√©_vazia():
            raise IndexError("Fila vazia. N√£o √© poss√≠vel desenfileirar.")

        if self.front == self.rear:  # Se a fila tem apenas um elemento
            self.front = None
            self.rear = None
        else:  # Se houver mais de um elemento
            self.front = self.front.next
            self.rear.next = self.front

        self.size -= 1  # Decrementa o tamanho da fila

    def frente(self):
        """
        Retorna o valor do elemento na frente da fila, sem remov√™-lo.
        """
        if self.fila_√©_vazia():
            raise IndexError("Fila vazia. N√£o h√° elemento na frente.")
        return self.front.value

    def tamanho(self):
        """
        Retorna o tamanho da fila.
        """
        return self.size

    def exibir(self):
        """
        Exibe os elementos da fila.
        """
        if self.fila_√©_vazia():
            print("Fila vazia.")
            return

        current = self.front
        print("Fila: ", end="")
        while current != self.rear:
            print(current.value, end=" -> ")
            current = current.next
        print(current.value)  # Exibe o √∫ltimo elemento

# Fun√ß√£o para medir o tempo de execu√ß√£o
def measure_time(func, *args):
    start_time = time.time()
    func(*args)
    end_time = time.time()
    return end_time - start_time

# Testando a implementa√ß√£o e medindo o tempo de execu√ß√£o
for size in [1000, 10000, 1000000]:
    fila = FilaCircular()

    # Medindo o tempo de inicializa√ß√£o
    init_time = measure_time(fila.__init__)
    print(f"Tempo de inicializa√ß√£o: {init_time:.6f} segundos")
    print(f"Tamanho do deque: {size}")

    # Inserindo elementos na fila
    for i in range(size):
        fila.insere_fila(i)

    # Exibindo os resultados de inser√ß√£o
    # N√£o exibindo a sequ√™ncia dos n√∫meros, apenas a confirma√ß√£o de que a opera√ß√£o foi realizada

    # Removendo alguns elementos para testar o comportamento
    for i in range(size // 10):  # Remover 10% dos elementos
        fila.desenfileira()

    # Exibindo a fila ap√≥s remo√ß√µes
    # N√£o exibindo a sequ√™ncia, apenas confirmando que o deque foi modificado

"""**Complexidade das opera√ß√µes principais:**

Inser√ß√£o (insere_fila): O(1)

Remo√ß√£o (desenfileira): O(1)

Acesso ao primeiro (frente): O(1)

Verifica√ß√µes (fila_√©_vazia, fila_√©_cheia): O(1)

Exibi√ß√£o (exibir): O(n)

**Tempo de Execu√ß√£o:**

O tempo de execu√ß√£o das opera√ß√µes principais de inser√ß√£o e remo√ß√£o foi muito baixo, indicando que o uso de uma estrutura de fila circular ligada √© eficiente. O tempo de inicializa√ß√£o foi em torno de microssegundos, com a execu√ß√£o das inser√ß√µes e remo√ß√µes r√°pidas, mesmo para tamanhos grandes de fila (1000000 elementos).

# Item E
"""

import time

class Node:
    def __init__(self, value):
        self.value = value
        self.next = None

class FilaCircular:
    def __init__(self):
        self.front = None
        self.rear = None
        self.size = 0

    def fila_√©_vazia(self):
        return self.size == 0

    def fila_√©_cheia(self):
        return False  # Como √© uma lista circular din√¢mica, n√£o tem limite de tamanho.

    def insere_fila(self, value):
        new_node = Node(value)
        if self.fila_√©_vazia():
            self.front = new_node
            self.rear = new_node
            new_node.next = self.front  # Aponta para si mesmo, formando a circularidade
        else:
            self.rear.next = new_node
            self.rear = new_node
            self.rear.next = self.front  # Mant√©m a circularidade
        self.size += 1

    def remove_fila(self):
        if self.fila_√©_vazia():
            raise IndexError("Fila est√° vazia!")
        if self.front == self.rear:  # Apenas um elemento na fila
            self.front = None
            self.rear = None
        else:
            self.front = self.front.next
            self.rear.next = self.front  # Atualiza a liga√ß√£o circular
        self.size -= 1

    def frente(self):
        if self.fila_√©_vazia():
            raise IndexError("Fila est√° vazia!")
        return self.front.value

    def tamanho(self):
        return self.size

    def exibir(self):
        if self.fila_√©_vazia():
            print("Fila vazia!")
            return
        current = self.front
        while True:
            print(current.value, end=" -> ")
            current = current.next
            if current == self.front:
                break
        print()

# Fun√ß√£o para medir o tempo de execu√ß√£o
def measure_time(func, *args):
    start_time = time.time()
    func(*args)
    end_time = time.time()
    return end_time - start_time

# Testando a implementa√ß√£o para diferentes tamanhos de fila
for size in [1000, 10000, 1000000]:
    fila = FilaCircular()

    # Medindo o tempo de inicializa√ß√£o
    init_time = measure_time(fila.__init__)
    print(f"Tamanho do deque: {size}")
    print(f"Tempo de inicializa√ß√£o: {init_time:.6f} segundos")

    # Inserindo elementos na fila
    for i in range(size):
        fila.insere_fila(i)

    # Removendo um elemento da fila
    fila.remove_fila()

    # Resultado sem exibir a sequ√™ncia de n√∫meros da fila
    print("Tempo de execu√ß√£o do remove_fila e tamanho ap√≥s remo√ß√£o:")
    print(f"Tamanho atual da fila: {fila.tamanho()}")

"""O tempo de execu√ß√£o depende do n√∫mero de elementos inseridos e removidos, mas como cada opera√ß√£o (inser√ß√£o e remo√ß√£o) √© O(1), o tempo de execu√ß√£o √© muito eficiente mesmo para grandes tamanhos de fila.

As opera√ß√µes insere_fila(), remove_fila(), fila_√©_vazia(), fila_√©_cheia() e frente() t√™m complexidade O(1), ou seja, s√£o realizadas em tempo constante.

A opera√ß√£o exibir() tem complexidade O(n), pois √© necess√°rio percorrer todos os elementos da fila para exibi-los.

# Item F
"""

import time

class Node:
    def __init__(self, value):
        self.value = value
        self.next = None

class FilaCircular:
    def __init__(self):
        self.front = None
        self.rear = None

    def fila_√©_vazia(self):
        return self.front is None

    def insere_fila(self, value):
        new_node = Node(value)
        if self.fila_√©_vazia():
            self.front = new_node
            self.rear = new_node
            new_node.next = new_node  # Circularidade
        else:
            new_node.next = self.front
            self.rear.next = new_node
            self.rear = new_node

    def remove_fila(self):
        if self.fila_√©_vazia():
            raise IndexError("A fila est√° vazia")
        if self.front == self.rear:  # Apenas um elemento
            removed_value = self.front.value
            self.front = None
            self.rear = None
        else:
            removed_value = self.front.value
            self.front = self.front.next
            self.rear.next = self.front
        return removed_value

    def imprimir(self):
        if self.fila_√©_vazia():
            print("A fila est√° vazia")
            return
        current = self.front
        elementos = []
        while True:
            elementos.append(current.value)
            if current == self.rear:
                break
            current = current.next
        print(" -> ".join(map(str, elementos)))

# Fun√ß√£o para medir o tempo de execu√ß√£o
def medir_tempo(fila, tamanho):
    start_time = time.time()
    for i in range(tamanho):
        fila.insere_fila(i)
    end_time = time.time()
    return end_time - start_time

# Testes com diferentes tamanhos
tamanhos = [1000, 10000, 1000000]

for tamanho in tamanhos:
    fila = FilaCircular()
    init_time = medir_tempo(fila, tamanho)
    print(f"Tamanho do deque: {tamanho}")
    print(f"Tempo de inicializa√ß√£o: {init_time:.6f} segundos\n")

"""O c√≥digo apresenta uma implementa√ß√£o eficiente de uma fila circular din√¢mica. Todas as opera√ß√µes b√°sicas t√™m complexidade O(1), exceto a impress√£o, que √© O(n).

O tempo de execu√ß√£o cresce linearmente com o tamanho da fila, sendo a fila adequada para aplica√ß√µes onde inser√ß√µes e remo√ß√µes r√°pidas s√£o necess√°rias.

**Tempo de Execu√ß√£o:**

Inser√ß√£o de N elementos: O(N), pois cada inser√ß√£o √© O(1).

Impress√£o de N elementos: O(N).

Complexidade das Opera√ß√µes:

fila_√©_vazia: O(1) ‚Äì Apenas verifica se o ponteiro front √© None.

insere_fila: O(1) ‚Äì Insere um novo n√≥ no final e ajusta os ponteiros.

remove_fila: O(1) ‚Äì Remove o n√≥ no in√≠cio e ajusta os ponteiros.

imprimir: O(n) ‚Äì Percorre todos os elementos da fila para exibi√ß√£o.


"""